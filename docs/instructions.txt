Note: words inside paranthesis "()" are optional

[x] nop;    0x00;   no operation

[x] stc;    ----;   
[x] sti;    0x01;   store (u)int constant on stack
[x] stf;    0x02;   store float constant on stack
[x] stb;    0x03;   store (u)byte constant on stack
[x] stis;   0x04;   store the (u)int at given symbol on stack
[x] stfs;   0x05;   store the float at given symbol on stack
[x] stbs;   0x06;   store the (u)byte at given symbol on stack

[x] ldc;    ----;   
[x] ldi;    0x07;   load (u)int from stack on heap and set &eax to address 
[x] ldf;    0x08;   load float from stack on heap and set &eax to address 
[x] ldb;    0x09;   load (u)byte from stack on heap and set &eax to address 

[x] rda;    ----;   
[x] rdi;    0x0A;   read (u)int from heap on heap at address &ebx and store it on stack
[x] rdf;    0x0B;   read float from heap on heap at address &ebx and store it on stack
[x] rdb;    0x0C;   read (u)byte from heap on heap at address &ebx and store it on stack
[x] rdr;    0x0D;   read the &<given_register> and store it on stack

[x] mov;    ----;
[x] movc;   0x0E;   set register to given constant value
[x] movs;   0x0F;   set register to the value at the top of the stack (based on register size)
[x] movr;   0x10;   set register to given register

[x] add;    ----;
[x] addi;   0x11;   pop and add two (u)ints from stack. push the result. 
[x] addf;   0x12;   pop and add two floats from stack. push the result. 
[x] addb;   0x13;   pop and add two (u)bytes from stack. push the result. 

[x] addr;   ----;
[x] addri;  0x14;   add the two (u)ints stored in given two registers and set the second one to result
[x] addrf;  0x15;   add the two floats stored in given two registers and set the second to result
[x] addrb;  0x16;   add the two (u)bytes stored in given two registers and set the second one to result

[x] adds;   ----;
[x] addsi;  0x17;   pop and add two (u)ints from stack. DO NOT POP. push the result. 
[x] addsf;  0x18;   pop and add two floats from stack. DO NOT POP. push the result. 
[x] addsb;  0x19;   add two (u)bytes on top of the stack. DO NOT POP. push the result. 

[x] hcp;    0x1A;   copy the heap starting at &eax to heap starting at &ebx with the size of &ecx
[x] scp;    0x1B;   copy the stack starting at &eax to stack starting at &ebx with the size of &ecx 
~[ ] rcp;    0x1C;   copy the stack starting at &eax to given symbol with the size of &ebx~

% The increments are not by one but by a given constant. Must be known at compile time.

[ ] inc;    ----;
[ ] inci;   0x1D;   increment the (u)int at the top of the stack
[ ] incf;   0x1E;   increment the float at the top of the stack
[ ] incb;   0x1F;   increment the (u)byte at the top of the stack

[ ] incr;   0x20;   increment the register

[ ] incs;   ----;   
[ ] incsi;  0x21;   increment the (u)int at the top of the stack, don't modify but push
[ ] incsf;  0x22;   increment the (u)int at the top of the stack, don't modify but push
[ ] incsb;  0x23;   increment the (u)int at the top of the stack, don't modify but push
